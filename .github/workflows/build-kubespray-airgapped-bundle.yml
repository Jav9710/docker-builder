name: "Kubespray: Build offline bundle"

on:
  workflow_dispatch:
    inputs:
      kubespray_version:
        description: 'Kubespray release/tag to use'
        required: true
        default: 'v2.27.0'
      kubernetes_version:
        description: 'Kubernetes version to prepare'
        required: true
        default: '1.31.9'
      cni:
        description: 'CNI to include (calico|cilium|flannel|weave|kube-ovn|kube-router|multus)'
        required: true
        default: 'cilium'
      target_os:
        description: 'Target node OS'
        required: true
        default: 'ubuntu22.04'
      artifact_name:
        description: 'Artifact name to produce'
        required: false
        default: 'kubespray-offline-artifact.tar.gz'

env:
  # Default versions that would normally match the kubespray_version
  ETCD_VERSION: '3.5.21'
  DOCKER_VERSION: '26.1'
  CONTAINERD_VERSION: '1.7.27'
  CRIO_VERSION: '1.31.6'
  CNI_PLUGINS_VERSION: '1.4.1'
  CALICO_VERSION: '3.29.4'
  CILIUM_VERSION: '1.15.9'
  FLANNEL_VERSION: '0.22.0'
  KUBE_OVN_VERSION: '1.12.21'
  KUBE_ROUTER_VERSION: '2.0.0'
  MULTUS_VERSION: '3.8'
  WEAVE_VERSION: '2.8.7'
  KUBE_VIP_VERSION: '0.8.0'
  CERT_MANAGER_VERSION: '1.15.3'
  COREDNS_VERSION: '1.11.3'
  INGRESS_NGINX_VERSION: '1.12.1'
  KREW_VERSION: '0.4.4'
  ARGOCD_VERSION: '2.11.0'
  HELM_VERSION: '3.16.4'
  METALLB_VERSION: '0.13.9'
  REGISTRY_VERSION: '2.8.1'
  CEPHFS_PROVISIONER_VERSION: '2.1.0-k8s1.11'
  RBD_PROVISIONER_VERSION: '2.1.1-k8s1.11'
  AWS_EBS_CSI_PLUGIN_VERSION: '0.5.0'
  AZURE_CSI_PLUGIN_VERSION: '1.10.0'
  CINDER_CSI_PLUGIN_VERSION: '1.30.0'
  GCP_PD_CSI_PLUGIN_VERSION: '1.9.2'
  LOCAL_PATH_PROVISIONER_VERSION: '0.0.24'
  LOCAL_VOLUME_PROVISIONER_VERSION: '2.5.0'
  NODE_FEATURE_DISCOVERY_VERSION: '0.16.4'

jobs:
  build-offline:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python (for running helper scripts)
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install prerequisites
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl tar gzip ca-certificates git podman

      - name: Fetch Kubespray (requested tag)
        env:
          TAG: ${{ github.event.inputs.kubespray_version }}
        run: |
          set -e
          rm -rf kubespray
          git clone --depth 1 --branch "${TAG}" https://github.com/kubernetes-sigs/kubespray.git kubespray
          echo "KUBESPRAY_DIR=$(pwd)/kubespray" > $GITHUB_ENV

      - name: Create config for offline generation
        run: |
          mkdir -p offline-output
          cat > offline-output/config.env <<EOF
          KUBESPRAY_DIR=${{ env.KUBESPRAY_DIR }}
          K8S_VERSION=${{ github.event.inputs.kubernetes_version }}
          CNI=${{ github.event.inputs.cni }}
          ETCD_VERSION=${{ env.ETCD_VERSION }}
          CONTAINERD_VERSION=${{ env.CONTAINERD_VERSION }}
          TARGET_OS=${{ github.event.inputs.target_os }}
          ARTIFACT_NAME=${{ github.event.inputs.artifact_name }}
          EOF
          ls -la offline-output && cat offline-output/config.env

      - name: Add offline-download helper script
        run: |
          cat > offline-output/generate-offline.sh <<'BASH'
          #!/usr/bin/env bash
          set -euo pipefail
          cd "$(dirname "$0")"
          source ./config.env

          # 1) prepare work dirs
          mkdir -p outputs/images outputs/binaries outputs/pypi outputs/os-pkgs

          # 2) get kubespray (already cloned)
          KUBE_DIR="${KUBESPRAY_DIR}"
          echo "Using Kubespray at ${KUBE_DIR}"

          # 3) Resolve container image list from Kubespray roles (simple approach):
          #    - Use the roles/download/defaults or group_vars to build images list
          #    - For robustness we fall back to using a community generator (kubespray-offline)
          #
          # Try to use kubespray-offline if available (recommended); otherwise use a basic image gatherer.
          if [ ! -d "kubespray-offline" ]; then
            echo "Cloning kubespray-offline helper..."
            git clone --depth 1 https://github.com/kubespray-offline/kubespray-offline.git || true
          fi

          # 4) Use the helper repo's download-all.sh if present (it fetches images, pyPI, yum/deb repos)
          if [ -f kubespray-offline/download-all.sh ]; then
            echo "Using kubespray-offline/download-all.sh to fetch artifacts (recommended path)..."
            pushd kubespray-offline
            # make a minimal config edit so scripts target the requested versions
            sed -i "s/^KUBESPRAY_VERSION=.*$/KUBESPRAY_VERSION=${K8S_VERSION:-${K8S_VERSION}}/g" config.sh || true || true
            ./download-all.sh || { echo "download-all.sh failed â€” script will attempt fallback"; popd; }
            popd || true
          fi

          # 5) Fallback: gather images using kubespray's images list roles (best-effort)
          echo "Gathering image list from Kubespray (best-effort)..."
          python3 - <<PY
          import yaml,sys,os,re,subprocess
          base='${KUBE_DIR}'
          images=set()
          # look for yaml files that define images under roles or contrib
          for root,dirs,files in os.walk(base):
              for f in files:
                  if f.endswith(('.yml','.yaml')):
                      p=os.path.join(root,f)
                      try:
                          txt=open(p,'r',errors='ignore').read()
                          # rough regex for "image:" or "repository:tag"
                          for m in re.findall(r'([A-Za-z0-9./:-_]+/(?:[^\\s\'"]+):[0-9a-zA-Z._-]+)', txt):
                              images.add(m)
                      except Exception:
                          pass
          # add obvious Kubespray images for kubeadm/kubelet etc
          images.update([
            "k8s.gcr.io/kube-apiserver:${}".format('${K8S_VERSION}')
          ])
          out = sorted(images)
          print("\n".join(out))
          PY > outputs/images-to-pull.txt || true

          # 6) Pull and save images (podman)
          echo "Pulling images list (first 200 lines):"
          head -n 200 outputs/images-to-pull.txt || true
          while read -r img; do
            [ -z "$img" ] && continue
            echo "Pull: $img"
            podman pull --tls-verify=false "$img" || podman pull "$img" || echo "WARN: failed to pull $img"
            podman save -o outputs/images/"$(echo $img | tr '/:' '_').tar" "$img" || echo "WARN: save failed for $img"
          done < outputs/images-to-pull.txt || true

          # 7) Download kube binaries for the requested Kubernetes version
          K8S="${K8S_VERSION}"
          KD="outputs/binaries"
          mkdir -p $KD
          echo "Downloading kubeadm, kubelet, kubectl for v${K8S}..."
          baseurl="https://storage.googleapis.com/kubernetes-release/release/v${K8S}/bin/linux/amd64"
          for b in kubeadm kubelet kubectl; do
            url="${baseurl}/${b}"
            echo "GET $url"
            curl -sSL --retry 5 -o "${KD}/${b}-v${K8S}" "$url" || echo "WARN: cannot download $b"
            chmod +x "${KD}/${b}-v${K8S}" || true
          done

          # 8) Optionally tar everything into a single artifact
          artifact="${ARTIFACT_NAME:-kubespray-offline-artifact.tar.gz}"
          echo "Packaging artifact ${artifact}..."
          tar -C outputs -czf "../${artifact}" outputs || true
          echo "DONE: artifact at ../${artifact}"
          BASH
          chmod +x offline-output/generate-offline.sh

      - name: Run offline generator (this produces the tar.gz artifact)
        run: |
          pushd offline-output
          ./generate-offline.sh
          popd
          ls -lh offline-output || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.event.inputs.artifact_name }}
          path: offline-output/${{ github.event.inputs.artifact_name }}
