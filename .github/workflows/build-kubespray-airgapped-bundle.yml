name: "Kubespray: Build offline bundle"

on:
  workflow_dispatch:
    inputs:
      kubespray_version:
        description: 'Kubespray release/tag to use'
        required: true
        default: 'v2.27.0'
      kubernetes_version:
        description: 'Kubernetes version to prepare'
        required: true
        default: 'v1.28.5'
      cni:
        description: 'CNI to include (calico|cilium|flannel|weave|kube-ovn|kube-router|multus)'
        required: true
        default: 'calico'
      target_os:
        description: 'Target node OS'
        required: true
        default: 'ubuntu22.04'
      artifact_name:
        description: 'Artifact name to produce'
        required: false
        default: 'kubespray-offline-bundle.tar.gz'

env:
  # Container Runtimes
  CONTAINERD_VERSION: '1.7.11'
  CRIO_VERSION: '1.28.2'
  DOCKER_VERSION: '24.0.7'

  # Core Components
  ETCD_VERSION: '3.5.10'
  CNI_PLUGINS_VERSION: '1.3.0'
  COREDNS_VERSION: '1.11.1'
  HELM_VERSION: '3.14.1'

  # CNI Versions
  CALICO_VERSION: '3.26.1'
  CILIUM_VERSION: '1.14.5'
  FLANNEL_VERSION: '0.22.0'
  KUBE_OVN_VERSION: '1.12.0'
  WEAVE_VERSION: '2.8.1'

jobs:
  build-offline-bundle:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            jq \
            curl \
            tar \
            gzip \
            git \
            podman \
            python3-venv

      - name: Clone Kubespray
        env:
          KUBESPRAY_VERSION: ${{ inputs.kubespray_version }}
        run: |
          set -e
          rm -rf kubespray
          git clone --depth 1 --branch "${KUBESPRAY_VERSION}" \
            https://github.com/kubernetes-sigs/kubespray.git kubespray
          echo "KUBESPRAY_DIR=$(pwd)/kubespray" >> $GITHUB_ENV

      - name: Create configuration
        run: |
          mkdir -p offline-bundle
          cat > offline-bundle/config.env <<EOF
          KUBESPRAY_DIR=${{ env.KUBESPRAY_DIR }}
          KUBERNETES_VERSION=${{ inputs.kubernetes_version }}
          CNI=${{ inputs.cni }}
          TARGET_OS=${{ inputs.target_os }}
          ARTIFACT_NAME=${{ inputs.artifact_name }}
          # Container Runtimes
          CONTAINERD_VERSION=${{ env.CONTAINERD_VERSION }}
          CRIO_VERSION=${{ env.CRIO_VERSION }}
          # Core Components
          ETCD_VERSION=${{ env.ETCD_VERSION }}
          CNI_PLUGINS_VERSION=${{ env.CNI_PLUGINS_VERSION }}
          # CNI Versions
          CALICO_VERSION=${{ env.CALICO_VERSION }}
          CILIUM_VERSION=${{ env.CILIUM_VERSION }}
          EOF

      - name: Generate download script
        run: |
          cat > offline-bundle/download.sh <<'SCRIPT'
          #!/usr/bin/env bash
          set -euo pipefail

          # Load configuration
          source ./config.env

          # Set default artifact name if not provided
          if [ -z "${ARTIFACT_NAME}" ]; then
            ARTIFACT_NAME="kubespray-offline-bundle.tar.gz"
          fi

          # Create directory structure
          mkdir -p \
            artifacts/images \
            artifacts/binaries \
            artifacts/packages \
            artifacts/pip

          # Download Kubernetes binaries
          echo "Downloading Kubernetes binaries..."
          K8S_BINARIES=(
            "kubeadm"
            "kubelet"
            "kubectl"
          )

          for binary in "${K8S_BINARIES[@]}"; do
            echo "Downloading ${binary}..."
            curl -L --retry 5 --output "artifacts/binaries/${binary}" \
              "https://dl.k8s.io/release/${KUBERNETES_VERSION}/bin/linux/amd64/${binary}" || \
              { echo "Failed to download ${binary}"; exit 1; }
            chmod +x "artifacts/binaries/${binary}"
          done

          # Download container images
          echo "Downloading container images..."
          IMAGES=(
            "k8s.gcr.io/kube-apiserver:${KUBERNETES_VERSION}"
            "k8s.gcr.io/kube-controller-manager:${KUBERNETES_VERSION}"
            "k8s.gcr.io/kube-scheduler:${KUBERNETES_VERSION}"
            "k8s.gcr.io/kube-proxy:${KUBERNETES_VERSION}"
            "k8s.gcr.io/pause:3.9"
          )

          for image in "${IMAGES[@]}"; do
            echo "Pulling ${image}..."
            podman pull "${image}" || { echo "Failed to pull ${image}"; exit 1; }
            podman save -o "artifacts/images/$(echo ${image} | tr '/:' '_').tar" "${image}" || \
              { echo "Failed to save ${image}"; exit 1; }
          done

          # Create final bundle (in the same directory)
          echo "Creating bundle archive ${ARTIFACT_NAME}..."
          tar -czvf "${ARTIFACT_NAME}" artifacts || \
            { echo "Failed to create bundle archive"; exit 1; }
          
          echo "Successfully created bundle: ${ARTIFACT_NAME}"
          SCRIPT

          chmod +x offline-bundle/download.sh

      - name: Execute download script
        run: |
          cd offline-bundle
          ./download.sh
          ls -lh # Debug: Show created files

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: offline-bundle/${{ inputs.artifact_name }}
